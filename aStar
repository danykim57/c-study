#include<iostream>
using namespace std;

#define ROW 9
#define COL 10
typedef pair<int, int> Pair;

typedef pair<double, pair<int, int>> pPair;

struct cell {
	int parent_i, parent_j;
	double f, g, h;
};

bool isValid(int row, int col) {
	return (row >= 0) && (row < ROW) && (col >= 0) && (col < COL);
}

bool isDesetination(int row, int col, Pair dest) {
	if (row == dest.first && col == dest.second)
		return true;
	else
		return false;
}

double calculateHValue(int row, int col, Pair dest) {
        return ((double)sqrt(
	    (row - dest.first) * (row - dest.first)
	    + (col = dest.second) * (col - dest.second)));
}

void tracePath(cell cellDetails[][COL], Pair dest) {
	cout << "\nThe Path is ");
	int row = dest.first;
	int col = dest.second;

	stack<Pair> path;

	while (!(cellDetails[row][col].parent_i == row && cellDetails[row][col].parent_j == col)) {
		Path.push(make_pair(row, col));
		int temp_row = cellDetails[row][col].parent_i;
		int temp_col = cellDetails[row][col].parent_j;
		row = temp_row;
		col = temp_col;
	}

	Path.push(make_pair(row, col));
	while (!Path.empty()) {
		pair<int, int> p = Path.top();
		Path.pop();
		cout << "-> "<< p.first << p.second;
	}
	return;
}

void aStarSearch(int grid[][COL], Pair src, Pair dest) {
	if (isValid(src.first, src.second) == false) {
		cout << "Source is invalid\n";
		return;
	}

	if (isValid(dest.first, dest.second) == false) {
		cout << "Destination is invalid\n";
		return;
	}

	if (isUnBlocked(grid, src.first, src.second) == false || isUnBlocked(grid, dest.first, dest.second) == false) {
		cout << "Source or the destination is blocked\n";
		return;
	}

	if (isDestination(src.first, src.second, dest) == true) {
		cout << "We are already at the destination\n";
		return;
	}
}
